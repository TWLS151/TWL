SWEA 1244 

이 문제를 풀고 자존심이 많이 상했다.


일단 내가 오랜 시간동안 알고리즘 공부를 놓았다는 증명처럼 느껴졌고, 결국 한번에 맞추지도 못 했다.


일단 코드 드립니다.
### 코드 
---
```python 
def dfs(cnt):
    if cnt == K:
        # K번째 교환에 도달했을 때만 결과 세트에 추가
        results.add("".join(nums))
        return

    for i in range(N):
        for j in range(i + 1, N):
            nums[i], nums[j] = nums[j], nums[i]
            
            state = ("".join(nums), cnt)
            if state not in visited:
                visited.add(state)
                dfs(cnt + 1)
            
            nums[i], nums[j] = nums[j], nums[i]


T = int(input())

for tc in range(1, T + 1):
    num, K = input().split()
    nums = list(num)
    K = int(K)
    N = len(nums)

    results = set()  # K번째 결과들을 저장할 세트
    visited = set()  # 중복 탐색 방지용

    dfs(0)

    ans = max(int(x) for x in results)  # results에서 최댓값 찾기
    print(f"#{tc} {ans}")
```
---

결국 그냥 모든 부분을 바라보는 재귀함수를 이용해서 문제를 풀었다.


그리고 가지치기 같은 방식은 취하지도 않았다.



원래 나의 계획을 말해주겠다.

1. 리스트의 첫번째자리에 가장 큰 수 교환
2. L[1:] 으로 인덱싱해서 안으로 찾아들어가며 원하는 횟수까지 반복
3. 출력

이걸 구현했는데 알고보니 예제도 통과하지 못하는 멍청한 구현법이었다.


결국 주어진 수만큼 이동한 모든 경우의 수를 저장하고, 그 중에서 MAX함수를 갈기는게 정답이었다.


너무 꼬아서 생각해버린....

그리고 댓글을 보고 치사하게 풀었다.

몇개 꼬리 케이스는 반영이 안된다는 허술한 점을 찾고 그 부분을 대충 풀었다.


그래서 자존심이 너무 상했다.

나 코드 좀 친다고 뒤지게 꺼드럭 댔으면서, 이것도 똑바로 못 풀다니.

이 정도로 멈추면 안되겠다는 굳은 다짐을 하기로 했다.

그래서 집에 와서 코드를 꼬리 테스트 케이스도 해결할 수 있게 다시 짰다.

그래야만 마음이 풀릴 것 같았다.

아무튼 그랬다.


오늘의 코드 마무리는 여기까지.




