# Data Structure 1


## 데이터 구조
- 여러 데이터를 효과적으로 사용, 관리하기 위한 구조
- str, list, dict 등
- 자료 구조


## 메서드
- *객체*에 속한 함수. *클래스* 내부에 정의되는 함수. 객체가 특정 작업을 수행하도록 정의됨
    - 객체 : 특정 데이터(정보)와 그 데이터를 처리하는 기능(메서드)을 하나로 묶은 것
    - 클래스 : 타입을 표현하는 방법.타입을 만들어내는 주체
- 문자열, 리스트, 딕셔너리 등 각 *데이터 구조*가 가지는 고유한 메서드를 *호출*하여 특정 기능을 수행
    > 데이터 타입 객체.메서드()


## 공통 시퀀스 메서드
- sq.index(x) : 인덱스 *반환*
    - 탐색
- sq.count(x) : 개수 *반환*


## 불변 시퀀스 메서드 (*문자열* 전용)

### 탐색 및 검증
- str.find(x) : 위치(없으면 -1) *반환*
- str.isupper() : T/F *반환*
- str.islower() : T/F *반환*
- str.isalpha() : T/F *반환*

### 문자열 조작


## 가변 시퀀스 메서드 (*리스트* 전용)

### 값 추가 및 삭제


### 정렬


### 복사


### 객체와 참조
- 가변 객체(Mutable) : 생성 후 내용 변경 가능
 - 리스트, 딕셔너리, 세트
 - 객체의 내용이 변경되어도 같은 메모리 주소 유지
- 불변 객체(Immutable) : 생성 후 내용 변경 불가
    - 정수, 실수, 문자열, 튜플
    - 새로운 값을 할당(재할당)하면 새로운 객체 생성, 변수는 새 객체를 참조하게 됨
- 변수 할당
    - 새로운 객체 생성 후 참조
    - 기존 객체 참조
- id() 함수 : 메모리 주소 확인. 내장 함수
- is 연산자 : 두 변수가 같은 객체를 참조하는지 확인



### 얕은 복사
- 객체의 *최상위 요소*만 새로운 메모리에 복사
    - 원본 리스트와 동일한 내용의 새로운 리스트를 만듦
        -> 리스트 자체의 주소는 달라짐
    - 요소 자체의 값이 아닌 해당 요소들이 참조하는 주소를 복사
        -> 리스트 내 요소들의 주소는 여전히 같음
- 중첩된 객체는 참조만 복사됨
    - 즉 복사본의 중첩 객체는 여전히 원본 객체의 중첩 객체를 참조하고 있음
    - 원본 리스트와 복사본 리스트의 주소는 다르지만 내부 객체의 주소는 같음
    - 따라서 중첩된 리스트를 수정하면 원본 객체와 복사본 객체가 함께 변경됨
1. 리스트 슬라이싱
    > b = a[:]
2. copy 메서드
    > c = a.copy()
3. list() 함수
    > d = list(a)

### 깊은 복사
- 객체의 모든 수준의 요소를 새로운 메모리에 복사
- *중첩된 객체까지* 모두 새로운 객체로 생성됨
- 원본 객체와 복사본의 완전한 독립성 보장
1. copy 모듈 내 deepcopy() 함수 - 내장 모듈
    > import copy

        new_object = copy.deepcopy(original_object)


## 참고

### List Comprehension
- 간결하고 효율적인 리스트 생성 방법
    > [표현식 for 임시변수 in iterable if 조건]
- 'if 조건'은 선택 사항
- 2차원 배열(인접행렬) 생성 시
    > data_1 = [0] * 5 for _ in range(5)

    > data_2 =[[0 for _ in range(5)] for _ in range(5)]

### 리스트 생성 방법
1. loop
    > result_1 = [ ]

        for i in range(10):
            result_1.append(i)

2. list compressente
    > result_2 = [i for i in range(10)]

3. map
    > result_e = list(map(lambda i: i, range(10)))

### 메서드 체이닝
- 여러 메서드를 연속해서 호출하는 방식
    > 객체.메서드1().메서드2()
- 메서드1, 메서드2 순으로 실행됨
- 객체를 반환하는 메서드만 체이닝 가능
- None을 반환하는 메서드는 체이닝 불가능
- [PITFALL]
1. 메서드1의 반환값이 없을 경우
    > AttributeError: 'NoneType' object has no attribute '메서드2'
    - 메서드1이 반환한 None 뒤에 메서드2를 이을 수 없음
2. 메서드2의 반환값이 없을 경우
    > None
    - None을 반환하므로 변수에 아무것도 저장되지 않음

### 문자 유형 판별 메서드



